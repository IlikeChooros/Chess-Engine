#pragma once

#include <algorithm>

#include "eval.h"
#include "move.h"
#include "board.h"
#include "transp_table.h"

namespace chess
{

    // Move ordering for move lists, based on the 
    // pricipal variation, captures and history heuristic
    class MoveOrdering
    {
    public:
        MoveOrdering() = default;

        // Class to give value to moves, giving priority to PV moves, captures and history heuristic
        class OrderedMove
        {
            static inline int captured_value(Move m, Board* b)
            {
                // The value of the captured piece
                return Eval::piece_values[Piece::getType(b->board[m.getTo()]) - 1] 
                    - Eval::piece_values[Piece::getType(b->board[m.getFrom()]) - 1];
            }

        public:
            Move move = Move::nullMove;
            int value = 0;

            OrderedMove() = default;

            /**
             * @brief Set the move and its value
             * @param m Move to set the Value
             * @param pvm hash move for this position (null-move if non-existent)
             * @param b board state
             * @param sc search cache has history and killer heuristic stored  
             * @param ply Current distance from the `root` position
             * @param danger Enemy attacks bitboard
             * @param endgame_factor Generated by Eval, from 0 - `MAX_ENDGAME_FACTOR`, 
             * indicates how close the game is to endgame
             * @param middlegame_factor `MAX_ENDGAME_FACTOR` - endgame_factor
             */
            inline void set(
                const Move& m, const Move& pvm, 
                Board* b, SearchCache* sc, Depth ply,
                Bitboard danger, int endgame_factor, 
                int middlegame_factor
            )
            {
                constexpr int 
                    bias_multipier       = 10000,
                    pv_bias              = 100 * bias_multipier,
                    winning_capture_bias = 8 * bias_multipier,
                    killer_bias          = 4 * bias_multipier,
                    promotion_bias       = 3 * bias_multipier,
                    losing_capture_bias  = 2 * bias_multipier,
                    regular_bias         = 0;

                move  = m;
                value = regular_bias;

                auto from         = m.getFrom();
                auto to           = m.getTo();
                auto moving_piece = b->board[from];
                auto piece_type   = Piece::getType(moving_piece);
                auto turn         = b->turn();

                // Add the pricipal variation bias (if the move is pv move)
                value += (pvm == m) * pv_bias;
                
                // If that's a capture, apply biases, and add the delta
                // So that, the moves will be ordered with captures 
                // of least valuable pieces capturing most valuable pieces
                if (m.isCapture())
                {
                    auto delta = captured_value(m, b);

                    // Apply capture bias
                    value += (delta < 0) ? losing_capture_bias : winning_capture_bias;
                    value += delta;
                }
                
                if (piece_type == Piece::Pawn)
                    value += (m.isPromotion() && !m.isCapture()) * promotion_bias;                
                
                if (piece_type != Piece::King)
                {
                    // Add the piece square tables 
                    // (so the moves that improve the position of the piece are ordered 1st)
                    auto mid_sq_table = Eval::piece_square_table[turn][Eval::MIDDLE_GAME][piece_type-1];
                    auto end_sq_table = Eval::piece_square_table[turn][Eval::ENDGAME][piece_type-1];

                    value += (mid_sq_table[to] - mid_sq_table[from]) * middlegame_factor
                        + (end_sq_table[to] - mid_sq_table[from]) * endgame_factor;
                    
                    // Check if we are moving into attacked squares
                    if ((danger & to) != 0)
                        value -= 100;
                }

                // Evaluate the quiet moves, based on killer and history heuristic
                if (!m.isCapture())
                {
                    value += sc->getKH().is_killer(m, ply) * killer_bias;
                    value += sc->getHH().get(b->turn(), m);
                }
            }
        };

        static constexpr bool greater(const OrderedMove& __x, const OrderedMove& __y)
        {
            return __x.value > __y.value;
        }

        /**
         * @brief Order the moves in the move list, modifies the list in place
         */
        static void sort(MoveList *ml, Move pv, Board *b, SearchCache* sc, Depth ply = 0);
    };
}